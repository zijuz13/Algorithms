第一章	绪论
随着互联网和计算机的快速发展，零售行业信息化程度都迅速提高，企业对客户信息资源的管理与维护需求也随之骤增并且对于会员客户的合理化营销也对企业的发展产生了重要的影响。由于企业对于客户信息管理的规模总量巨大，在未来的企业信息化的发展过程中，务必会出现规模越来越大的营销需求，业务逻辑也会越来越复杂，所以我们需要建立完善的自动化营销体系，完成数据收集、客户营销的一站式服务。
企业营销系统可以帮助企业建立自有的数据中心、汇集全渠道的客户数据。通过多种渠道将客户数据汇集到营销系统，解决信息孤岛的问题。并且利用数据管理审查数据完整度，便于营销人员分析，通过策划营销活动，逐步完善补足数据。最为重要的是，将用户数据进行筛选后，利用微信、邮件、短信等渠道进行自动的个性化营销，实现多渠道联动，多条件触发，减少人为操作，大幅度提高工作效率。

1.1	论文的背景及意义
在当今世界，营销成为了一个企业推广自己所必不可少的方式。数字营销是指通过数字渠道（例如搜索引擎，网站，电子邮件和微信短信息）投放的广告。数字营销就是使用这些渠道，推广公司的商品，服务和品牌的方法。同时，如今消费者严重依赖数字营销手段来了解产品。例如，《Think with Google》的营销报告发现，49％的消费者是在搜索引擎上开始查询的，而33％的消费者是通过电子邮件的推广了解产品，而26％的用户是在移动应用程序中推送来了解商品的。

想要实现现代数字营销就意味着营销人员必须在其品牌上加入的庞大的营销管理系统，。为了发挥数字营销的真正潜力，营销系统的开发必须深入研究当今广阔而复杂的跨渠道世界，以发现通过互动营销产生的影响。互动营销就是收集相关的客户数据并且联系其与潜在客户之间的关系的一种营销手段，通过在数字环境中吸引客户，可以建立品牌知名度，成为行业领导羊，并且让客户在有意向购买该产品时第一个就会想到这个品牌。

对于数字营销的未来，我们未来可以看到随着可供消费者使用的可穿戴设备的数量持续增加，电子邮件营销将变得更加个性化，企业的营销也更加的精准。
1.2	国内外现状分析
1.2.1	国外研究现状
企业营销管理系统是企业信息管理系统的重要组成部分，因为零售行业的主要活动就是产品营销。西方发达国家的信息化建设起步比较， 企业信息系统建设相对比较完善，作为特殊行业的零售营销管理系统的建设在功能上和技术上都比较先进,，许多零售行业营销管理系统有效的结合CRM、 SCM，很大程度上提高了企业的综合竞争力[1]。除此之外，市场上也有许多知名的产品营销管理软件生产商，例如美国的Orade公司、德国的Sap公司。

另外，由于新冠疫情肆虐，导致人们更多的网上购物。因此越来越多的中小企业选择设计并使用企业营销管理系统，通过更大资金投入并且不断开拓创新相关的技术，如多线程高并发，微服务架构等来完善企业营销管理系统。使得企业不仅能够将潜在用户的信息保留在自己的数据库中，并且可以通过像诸如大数据等手段分析出相应的报告对他们进行精准营销。并且经济增长缓慢，企业不能再单纯依靠规模经济的优势来站稳脚跟，继续投入大量的资金来招募大量的员工和有才华的人才来刺激企业的成长不再有效。然而，通过大量的高新技术来对企业进行数字化转型带来的提升却非常显著，这样就会在无形之中大幅度提升自己的利润。

1.2.2	国内研究现状
相比之下，国内的企业信息化建设起步比较晚，零售行业营销管理系统相对比较落后。随着对企业信息化重要性的认识加深，目前，国内许多零售行业大型公司已经建设完成或者正在筹建营销管理系统。已经有许多非常成功的例子，但是也出现一些失败的现象，因为一些企业只是盲目跟风，没有考虑本企业的实际需要，导致建设的营销管理系统不符合本企业的需要，根本无法为企业带来利润。除大中型企业外，大部分小型企业的营销管理系统还是采用传统的工作模式，人工记录、分析、统计数据，这种数据处理方式,不仅效率低下，而且一旦出现错误，很难检查出来，错误数据日积月累，很难保证统计数据的正确性[3]。纸质保存的数据很难进行查阅，也无法进行快速比较，而且容易损坏，不易备份数据。企业仍然采用传统营销管理模式的原因有企业负责人没有意识到产品营销管理信息化建设的重要性；短时间内无法体现信息化建设的价值；企业信息化建设需要投入大量的人力物力力求通过企业信息化建设来促进企业的快速发展,实现利益最大化

同时，中小企业在我国公司占比之大，并且在我国经济发展中占据有重要地位，并且横跨多个领域，分布在中国社会生活的方方面面，因此每年都有非常多的新型小公司诞生，也有非常多的公司因为数字化程度不够或者其他原因导致竞争力不足，而在市场上销声匿迹。就这样，中小企业之间的竞争一定是往着越来越激烈的趋势变化的，只有将数字化科技应用于企业之中，不仅能提高企业的效率，提升企业的利润，更加重要的是，还能够提升人民的生活水平，各个企业通过激烈的数字化竞争，可以产生出更加成熟的软件产品，并且这个产品通过多次迭代和演变，可以更加迎合用户的口味。因此，我们的企业营销系统必定要采用当今最流行的分布式架构来设计，同时必须具备可以生产上线的能力，如果企业需要，就可以部署运行。

并且，一个良好的企业营销系统必须可以适应一个企业多变的营销策略，这样可以带来非常多的好处。它可以用来击败竞争对手并同时提高销售额和利润。我们都知道，如此多的企业在相同产品和服务上竞争。如何在其他方面脱颖而出将在很大程度上取决于营销策略的有效性，精心计划的数字营销策略将帮助品牌在与竞品相比之中彰显优势，真正建立品牌，并最终成为市场中的“大”品牌。但是，如今由于中国大多数公司的数字化水平较低，还不能应用上很多国外成熟的营销技术，并且提升数字化水平的手段有限，需要花费大量的时间。

1.3	论文工作内容
本文主要研究企业营销系统的设计和开发过程，包括当前数字营销的必要性以及企业营销系统在数字营销中所扮演的重要角色，国内外对企业营销系统应用的现状，实现一个与时俱进的企业营销系统的主要技术介绍（设计常用的多线程高并发技术，大数据搜索技术等），系统的各部分模块（例如营销模版模块，电子邮件、短信发送模块以及客户信息聚合模块等），系统各模块的业务需求分析以及模型，实现系统开发过程中用到的一些算法，设计框架中的源代码知识可以更好的结合业务逻辑来提高相应的响应效率等等。

首先调研了国内外企业营销系统的现状，并且据此分析国内的营销系统的需求，整理出相应的需求模型进行分析。对相应的需求模型设计相应的实现方案，例如微服务，前后端分离，分布式锁，高并发，算法等等，然后翻阅国外的技术网站查看相应的技术实现从而能够更好的将技术应用到项目中去。最后，按照需求开发相应的模块，并且使用单元测试技术和WebDriver等自动化测试技术对最后的项目进行测试。同时，本项目就是为了上线而打造的，所以相应的微服务部署都是经过周密考虑，在配置文件中也区分开发环境和生产环境，方便直接部署到容器Docker中去。在论文末尾会有详细的配置列表。


1.4	论文组织结构
论文一共有七个章节，各个章节的主要内容：

第一章：绪论。包括论文选题、对国内外现状相应系统和数字营销进行深度分析、论文工作内容和结构组织。

第二章:主要技术栈介绍。主要对本项目实现中运用的技术进行介绍，例如多线程，CAS, ReentrantLock,Vue.js, Spin Locks,前后端分离，鉴权，LomBok, Spring Cloud, Elasticsearch, Redis, RabbitMQ, Nginx, Docker等等技术进行介绍，并且通过对源码的分析来介绍为什么这些技术适合企业营销管理系统

第三章:主要数据结构与算法介绍。由于这个项目将来可能直接上线，所以代码质量需要尽可能优化，降低时间复杂度，本章详细介绍项目中会用到的用来提升效率的几种数据结构与算法，如ConcurrentHashMap, BinarySearchTree, DFS BFS剪枝等。

第三章：对企业营销管理系统的需求分析。通过实地在企业实习，以及对使用用户的走访调查总结出相应的需求，并通过用例图，时序图，类图等的方式将他们展示出来，方面后期开发能够对需求精准把控。

第四章: 由于现在企业的开发都是敏捷开发，本论文为了高度模拟企业开发流程，故引入了敏捷开发使用jenkins等敏捷开发组件实现CI\DI持续集成，方便部署上线，本章将对持续集成进行深入分析

第五章：对企业营销管理系统的实现，通过层层剖析前端MVVM的工作原理以及后端RestFUL api的相应作用以及负载均衡等功能，同时结合数据库中存储的数据库表之间字段以及elasticsearch中相应的搜索字段解析来达到对项目的深度剖析

第六章：对企业营销管理系统的测试，本项目开发中采用Junit和Swagger Mock来进行单元测试，上线后采用Webdriver作为测试工具，方便jenkins自动集成后自动测试,本章节主要对测试工具进行分析，以及分析为什么企业中广泛采取这种测试方式。
第七章：结束语。概括本论文的工作方向，以及相应的改进地方。



第二章	相关技术介绍
主要技术栈介绍。主要对本项目实现中运用的技术进行介绍，例如多线程，CAS, ReentrantLock,Vue.js, Spin Locks,前后端分离，鉴权，LomBok, Spring Cloud, Elasticsearch, Redis, RabbitMQ, Nginx, Docker等等技术进行介绍，并且通过对源码的分析来介绍为什么这些技术适合企业营销管理系统
2.1	Spring框架
Spring框架是Java平台的应用程序框架，并且具有inversion of control的作用，用于管理应用中常用的Bean。该框架的核心功能可以被任何Java应用程序使用，但是在Java EE（企业版）平台之上有一些用于构建Web应用程序的扩展。尽管该框架没有要求任何特定的编程模型，但它已作为Java EJB企业模型的补充在Java社区中流行。Spring框架是开源的。
要灵活运用spring的ioc就得先彻底了解它底层的工作原理，这样将会对后来的调试和运用带来很大的便利，下面将对spring的源码进行分析以方便，想要彻底了解spring框架就得先从循环依赖注入开始分析：
1.以单例的实例化来介绍spring的IOC
以某个自己需要初始化的singleton的webService为例，通过层层嵌套运行到doCreateBean()方法中，会在一个if判断中判断是否开启spring的循环依赖，默认是开启的，可以通过修改源代码或者Spring的BeanFactory提供的API来关闭循环依赖，判断是开启循环依赖后，运行以下方法
        this.addSingletonFactory(beanName, () -> {
            return this.getEarlyBeanReference(beanName, mbd, bean); //这行代码可以对传入的Bean对象做Proxy代理，做很多事情
        });
就可以将此还没有完全创建好的Bean对象加入到第三级缓存中(三级缓存可以查看下面的专门说明),这个第三级缓存会在有某bean需要循环注入时，从factory中得到此earlySingleton加入BeanFactory的earlySingletonObjects中方便后面再继续使用循环依赖，一旦循环调用结束，这个earlySingletonObject通过registerSingleton就进入到singleObjects(一个专门存储已经走完所用BeanDefinition生命周期的Bean的Map集合，一级缓存)，总流程概览：
IndexService webService互为聚合关系，且都通过@Autowired自动注入对方：
getBean("indexService")=>this.populateBean()中发现webService在singletonObjects的Map集合中没有且isSingletonCurrentlyInCreation(beanName)方法为false，那么就会返回null，实例化webService的BeanWrapper(BeanWrapper中封装实例对象已经属性描述器PropertyDescriptor)=>又走到this.populateBean()=>此时虽然singletonObjects中不存在这个BeanObject,但是isSingletonCurrentlyInCreation为true,走三级缓存拿对象，objectFactory中取earlySingleton后，在factory中删除相应factory，并且在earlySingletonObjects(第二级缓存)中加入此singletonObject方便后面还要对此对象进行循环依赖注入=>webService注入到IndexService,indexService完成剩下的生命周期
1.入口函数SpringApplication:
通过public static静态方法进入
public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
    return (new SpringApplication(primarySources)).run(args);
}
这里面包含两个过程
1.instantialize SpringApplication对象：
public SpringApplication(Class<?>... primarySources) {
    this((ResourceLoader)null, primarySources);
}

public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
    this.sources = new LinkedHashSet();

    this.bannerMode = Mode.CONSOLE; //控制台模式
    this.logStartupInfo = true;
    this.addCommandLineProperties = true;
    this.addConversionService = true;
    this.headless = true;
    this.registerShutdownHook = true;
    this.additionalProfiles = new HashSet();
    this.isCustomEnvironment = false;
    this.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, "PrimarySources must not be null");

    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));                                                                                                                                                            
    this.webApplicationType = WebApplicationType.deduceFromClasspath(); //从ClassPath推断这个APP是Reactive还是Servlet
    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = this.deduceMainApplicationClass();
}
2.进入run函数：
public ConfigurableApplicationContext run(String... args) {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();

    ConfigurableApplicationContext context = null;
    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList();
    this.configureHeadlessProperty();
    SpringApplicationRunListeners listeners = this.getRunListeners(args);
    listeners.starting();                                                                                                                                                        

    Collection exceptionReporters;  
    try {
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);
        this.configureIgnoreBeanInfo(environment);
        Banner printedBanner = this.printBanner(environment);
        context = this.createApplicationContext();
        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]{ConfigurableApplicationContext.class}, context);
        this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);
        this.refreshContext(context); //属性注入容器
        this.afterRefresh(context, applicationArguments);
        stopWatch.stop();
        if (this.logStartupInfo) {
            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);
        }

        listeners.started(context);
        this.callRunners(context, applicationArguments);
    } catch (Throwable var10) {
        this.handleRunFailure(context, var10, exceptionReporters, listeners);
        throw new IllegalStateException(var10);
    }

    try {
        listeners.running(context);
        return context;
    } catch (Throwable var9) {
        this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);
        throw new IllegalStateException(var9);
    }
}
3. refreshContext:
private void refreshContext(ConfigurableApplicationContext context) {
    this.refresh(context); //实例化BeanDefinition
    if (this.registerShutdownHook) {
        try {
            context.registerShutdownHook();
        } catch (AccessControlException var3) {
        }
    }

}
4.进入ApplicationContext的refresh进行实例化：
public void refresh() throws BeansException, IllegalStateException {
    synchronized(this.startupShutdownMonitor) {
        this.prepareRefresh();
        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
        this.prepareBeanFactory(beanFactory);

        try {
            this.postProcessBeanFactory(beanFactory);
            this.invokeBeanFactoryPostProcessors(beanFactory); //完成了BeanDefinitions的扫描
            this.registerBeanPostProcessors(beanFactory);
            this.initMessageSource();
            this.initApplicationEventMulticaster();
            this.onRefresh();
            this.registerListeners();
            this.finishBeanFactoryInitialization(beanFactory);
            this.finishRefresh();
        } catch (BeansException var9) {
            if (this.logger.isWarnEnabled()) {
                this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9);
            }

            this.destroyBeans();
            this.cancelRefresh(var9);
            throw var9;
        } finally {
            this.resetCommonCaches();
        }

    }
}
5.属性注入和循环依赖发生在 finishBeanFactoryInitialization();
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
        beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
    }

    if (!beanFactory.hasEmbeddedValueResolver()) {
        beanFactory.addEmbeddedValueResolver((strVal) -> {
            return this.getEnvironment().resolvePlaceholders(strVal);
        });                                                                                                                                                                   
    }

    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    String[] var3 = weaverAwareNames;
    int var4 = weaverAwareNames.length;

    for(int var5 = 0; var5 < var4; ++var5) {
        String weaverAwareName = var3[var5];
        this.getBean(weaverAwareName);
    }

    beanFactory.setTempClassLoader((ClassLoader)null);
    beanFactory.freezeConfiguration();
    beanFactory.preInstantiateSingletons();  //属性注入和对象初始化发生在这步骤；
}
6.BeanFactory的preInstantiateSingletons()方法解析：
public void preInstantiateSingletons() throws BeansException {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Pre-instantiating singletons in " + this);
    }

    List<String> beanNames = new ArrayList(this.beanDefinitionNames); //Deep Copy BeanDefinitionNames
    Iterator var2 = beanNames.iterator();

    while(true) {
        String beanName;
        Object bean;
        do {
            while(true) {
                RootBeanDefinition bd;
                do {
                    do {
                        do {
                            if (!var2.hasNext()) {
                                var2 = beanNames.iterator();

                                while(var2.hasNext()) {
                                    beanName = (String)var2.next();
                                    Object singletonInstance = this.getSingleton(beanName);
                                    if (singletonInstance instanceof SmartInitializingSingleton) {
                                        SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                        if (System.getSecurityManager() != null) {
                                            AccessController.doPrivileged(() -> {
                                                smartSingleton.afterSingletonsInstantiated();
                                                return null;
                                            }, this.getAccessControlContext());
                                        } else {
                                            smartSingleton.afterSingletonsInstantiated();
                                        }
                                    }
                                }

                                return;
                            }

                            beanName = (String)var2.next(); //取出所有的BeanName
                            bd = this.getMergedLocalBeanDefinition(beanName); //取出beanName所对应的BeanDefinition
                        } while(bd.isAbstract()); //单例对象实例化不会经过这行
                    } while(!bd.isSingleton());    //单例对象实例化不会经过这行

                } while(bd.isLazyInit());

                if (this.isFactoryBean(beanName)) {  //也不是FactoryBean
                    bean = this.getBean("&" + beanName);
                    break;
                }

                this.getBean(beanName);  //这行代码进入bean的生命周期的下一个阶段,从以上的while循环可以知道,bean scope是Prototype和FactoryBean的不会经过这行,因为factory会break,而prototype会继续循环,进不来
            }
        } while(!(bean instanceof FactoryBean)); //显然不是FactoryBean回头继续初始化其他

        FactoryBean<?> factory = (FactoryBean)bean; //如果是工厂bean，那么会推断此工厂是否是eagerinit,获得工厂bean,在下面的代码推断是否需要isEagerInit,即急迫加载,如果是急迫加载,直接this.getBean();
        boolean isEagerInit;
        if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
            SmartFactoryBean var10000 = (SmartFactoryBean)factory;
            ((SmartFactoryBean)factory).getClass();
            isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
        } else {
            isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
        }

        if (isEagerInit) {
            this.getBean(beanName);
        }
    }
}
7.进入this.getBean通过层层空壳函数，会进入如下代码： 
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
    String beanName = this.transformedBeanName(name); //对名字进行校验，验证bean的名字是否非法
    Object sharedInstance = this.getSingleton(beanName); //从Spring的三级缓存中去取Singleton对象
    Object bean;
    if (sharedInstance != null && args == null) {
        if (this.logger.isTraceEnabled()) {
            if (this.isSingletonCurrentlyInCreation(beanName)) {
                this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                   //因为这个对象依赖了一个正在初始化的对象，所以返回一个eagerly cached instance of singleton.
            } else {
                this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'"); //得到一个已经初始化成功的对象
            }
        }

        bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null); //不是工厂bean的话直接返回bean
    } else {
        if (this.isPrototypeCurrentlyInCreation(beanName)) {
            throw new BeanCurrentlyInCreationException(beanName);
        }

        BeanFactory parentBeanFactory = this.getParentBeanFactory();
        if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
            String nameToLookup = this.originalBeanName(name);
            if (parentBeanFactory instanceof AbstractBeanFactory) {
                return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
            }

            if (args != null) {
                return parentBeanFactory.getBean(nameToLookup, args);
            }

            if (requiredType != null) {
                return parentBeanFactory.getBean(nameToLookup, requiredType);
            }

            return parentBeanFactory.getBean(nameToLookup);
         }

        if (!typeCheckOnly) {                                                                                                                                                                                             
        }

        try {
            RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
            this.checkMergedBeanDefinition(mbd, beanName, args);
            String[] dependsOn = mbd.getDependsOn(); //对@DependsOn注解所标注的bean进行提前注册
            String[] var11;
            if (dependsOn != null) {
                var11 = dependsOn;
                int var12 = dependsOn.length;

                for(int var13 = 0; var13 < var12; ++var13) {
                    String dep = var11[var13];
                    if (this.isDependent(beanName, dep)) {//判断是否循环depends-on,spring不支持循环depends-on @DependsOn
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                    }

                    this.registerDependentBean(dep, beanName);

                    try {
                        this.getBean(dep); //对依赖bean提前进行注册
                    } catch (NoSuchBeanDefinitionException var24) {
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var24);
                    }
                }
            }

            if (mbd.isSingleton()) {
                sharedInstance = this.getSingleton(beanName, () -> {
                    try {
                        return this.createBean(beanName, mbd, args);
                    } catch (BeansException var5) {
                        this.destroySingleton(beanName);
                        throw var5;
                    }
                });
                bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
            } else if (mbd.isPrototype()) {
                var11 = null;

                Object prototypeInstance;
                try {
                    this.beforePrototypeCreation(beanName);
                    prototypeInstance = this.createBean(beanName, mbd, args);
                } finally {
                    this.afterPrototypeCreation(beanName);
                }

                bean = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
            } else {
                String scopeName = mbd.getScope();
                Scope scope = (Scope)this.scopes.get(scopeName);
                if (scope == null) {
                    throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                }

                try {
                    Object scopedInstance = scope.get(beanName, () -> {
                        this.beforePrototypeCreation(beanName);

                        Object var4;
                        try {
                            var4 = this.createBean(beanName, mbd, args);
                        } finally {
                            this.afterPrototypeCreation(beanName);
                        }

                        return var4;
                    });
                    bean = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                } catch (IllegalStateException var23) {
                    throw new BeanCreationException(beanName, "Scope '" + scopeName + "' is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton", var23);
                }
            }
        } catch (BeansException var26) {
            this.cleanupAfterBeanCreationFailure(beanName);
            throw var26;
        }
    }

    if (requiredType != null && !requiredType.isInstance(bean)) {
        try {
            T convertedBean = this.getTypeConverter().convertIfNecessary(bean, requiredType);
            if (convertedBean == null) {
                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
            } else {
                return convertedBean;
            }
        } catch (TypeMismatchException var25) {
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Failed to convert bean '" + name + "' to required type '" + ClassUtils.getQualifiedName(requiredType) + "'", var25);
            }

            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
        }
    } else {
        return bean;
    }
}
getSingleton中的具体代码：
public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
    Assert.notNull(beanName, "Bean name must not be null");
    synchronized(this.singletonObjects) {
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null) {
            if (this.singletonsCurrentlyInDestruction) {
                throw new BeanCreationNotAllowedException(beanName, "Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)");
            }

            if (this.logger.isDebugEnabled()) {
                this.logger.debug("Creating shared instance of singleton bean '" + beanName + "'");
            }

            this.beforeSingletonCreation(beanName); //这一步标记了beanCurrentlyInCreation
            boolean newSingleton = false;
            boolean recordSuppressedExceptions = this.suppressedExceptions == null;
            if (recordSuppressedExceptions) {
                this.suppressedExceptions = new LinkedHashSet();
            }

            try {
                singletonObject = singletonFactory.getObject();
                newSingleton = true;
            } catch (IllegalStateException var16) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    throw var16;
                }
            } catch (BeanCreationException var17) {
                BeanCreationException ex = var17;
                if (recordSuppressedExceptions) {
                    Iterator var8 = this.suppressedExceptions.iterator();

                    while(var8.hasNext()) {
                        Exception suppressedException = (Exception)var8.next();
                        ex.addRelatedCause(suppressedException);
                    }
                }

                throw ex;
            } finally {
                if (recordSuppressedExceptions) {
                    this.suppressedExceptions = null;
                }

                this.afterSingletonCreation(beanName);
            }

            if (newSingleton) {
                this.addSingleton(beanName, singletonObject);
            }
        }

        return singletonObject;
    }
}

8.Explanations of the singleton function above:
Spring工厂实现循环依赖的三级缓存：
2.ObjectFactory
3.earlySingletonObjects  
1.singletonObjects(Spring的一级缓存)

protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName); // private final Map<String, Object> singletonObjects = new ConcurrentHashMap(256）；用来存储所有已经初始化(属性已经成功注入)
// 的对象
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) { //发现没有初始化好且此对象正在初始化中
        synchronized(this.singletonObjects) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null && allowEarlyReference) {
                ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    singletonObject = singletonFactory.getObject();
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }

    return singletonObject;
}
private final Map<String, Object> singletonObjects = new ConcurrentHashMap(256）；
9.doCreateBean:
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
    BeanWrapper instanceWrapper = null;
    if (mbd.isSingleton()) {
        instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);
    }

    if (instanceWrapper == null) {
        instanceWrapper = this.createBeanInstance(beanName, mbd, args);
    }

    Object bean = instanceWrapper.getWrappedInstance(); //这个就是被new出的一个对象bean
    Class<?> beanType = instanceWrapper.getWrappedClass();
    if (beanType != NullBean.class) {
        mbd.resolvedTargetType = beanType;
    }

    synchronized(mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            try {
                this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            } catch (Throwable var17) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Post-processing of merged bean definition failed", var17);
            }

            mbd.postProcessed = true;
        }
    }

    boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName); //允许循环依赖
    if (earlySingletonExposure) {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references"); //缓存bean来方便后面潜在的循环依赖
        }

        this.addSingletonFactory(beanName, () -> {
            return this.getEarlyBeanReference(beanName, mbd, bean); //earlySingletonExposure和允许循环依赖的意思差不多，这时候此对象还没有被初始化，将一个
        });
    }

    Object exposedObject = bean;

    try {
        this.populateBean(beanName, mbd, instanceWrapper);
        exposedObject = this.initializeBean(beanName, exposedObject, mbd);
    } catch (Throwable var18) {
        if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
            throw (BeanCreationException)var18;
        }

        throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
    }

    if (earlySingletonExposure) {
        Object earlySingletonReference = this.getSingleton(beanName, false);
        if (earlySingletonReference != null) {
            if (exposedObject == bean) {
                exposedObject = earlySingletonReference;
            } else if (!this.allowRawInjectionDespiteWrapping && this.hasDependentBean(beanName)) {
                String[] dependentBeans = this.getDependentBeans(beanName);
                Set<String> actualDependentBeans = new LinkedHashSet(dependentBeans.length);
                String[] var12 = dependentBeans;
                int var13 = dependentBeans.length;

                for(int var14 = 0; var14 < var13; ++var14) {
                    String dependentBean = var12[var14];
                    if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                        actualDependentBeans.add(dependentBean);
                    }
                }

                if (!actualDependentBeans.isEmpty()) {
                    throw new BeanCurrentlyInCreationException(beanName, "Bean with name '" + beanName + "' has been injected into other beans [" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + "] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
                }
            }
        }
    }

    try {
        this.registerDisposableBeanIfNecessary(beanName, bean, mbd);
        return exposedObject;
    } catch (BeanDefinitionValidationException var16) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Invalid destruction signature", var16);
    }
}
10.楼上的addSingletonFactory的工厂类用来获得这个正在create的bean：
源码：
public interface ObjectFactory<T> {
    T getObject() throws BeansException;
}
        this.addSingletonFactory(beanName, () -> {
            return this.getEarlyBeanReference(beanName, mbd, bean);
        }); //判断是否要做aop
protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
    Object exposedObject = bean;
    if (!mbd.isSynthetic() && this.hasInstantiationAwareBeanPostProcessors()) {
        Iterator var5 = this.getBeanPostProcessors().iterator();

        while(var5.hasNext()) {
            BeanPostProcessor bp = (BeanPostProcessor)var5.next();
            if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor)bp;
                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);
            }
        }
    }

    return exposedObject;
}
protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {
    Assert.notNull(singletonFactory, "Singleton factory must not be null");
    synchronized(this.singletonObjects) {
        if (!this.singletonObjects.containsKey(beanName)) {
            this.singletonFactories.put(beanName, singletonFactory);
            this.earlySingletonObjects.remove(beanName);
            this.registeredSingletons.add(beanName);
        }

    }
}

11.
Spring三级缓存：
private final Map<String, Object> singletonObjects = new ConcurrentHashMap(256); //1.一级缓存 已经初始化后的单例对象缓存  单例池 spring容器
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap(16); //2.三级缓存 单例对象工厂，一旦返回成功一次早暴露的对象 
private final Map<String, Object> earlySingletonObjects = new HashMap(16); //3. 二级缓存 存在三级缓存是为了防止重复创建(因为多个实例可能依赖同个对象，你不能创建多个，直接存入三级缓存，以后每次从三级缓存中拿就行)，因为singletonFactories返回时会经过一系列步骤，这样也会节省时间
private final Set<String> registeredSingletons = new LinkedHashSet(256);   //已经注册的Bean的BeanNames,不一定要走完生命周期
private final Set<String> singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap(16)); //正在创建中的BeanNames
 
protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}  //通过这个方法标识上某个Bean正在创建过程中 
12.
注册Singleton到singletonObjects已注册bean中
public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {
    Assert.notNull(beanName, "Bean name must not be null");
    Assert.notNull(singletonObject, "Singleton object must not be null");
    synchronized(this.singletonObjects) {
        Object oldObject = this.singletonObjects.get(beanName);
        if (oldObject != null) {
            throw new IllegalStateException("Could not register object [" + singletonObject + "] under bean name '" + beanName + "': there is already object [" + oldObject + "] bound");
        } else { 
            this.addSingleton(beanName, singletonObject);
        }
    }
}
protected void addSingleton(String beanName, Object singletonObject) {
    synchronized(this.singletonObjects) {
        this.singletonObjects.put(beanName, singletonObject);
        this.singletonFactories.remove(beanName);
        this.earlySingletonObjects.remove(beanName);
        this.registeredSingletons.add(beanName);


2.2Spring Boot
SpringBoot是由Pivotal团队2013年进行开发设计的、并且在2014年4月发布第一个版本的全新开源的轻量级框架。结合Spring4.0，其拥有Spring框架所拥有的所有优良性质，最关键的是它可以进一步简化在之前Spring开发中臃肿的配置文件而造成程序员本应该专注于业务而因为基础框架的搭建而浪费了大量的时间。而SpringBoot这个脚手架通过大量的简化配置来使得Spring应用的搭建和开发全部过程变得如此轻松与容易，程序员可以更加专注于业务逻辑的设计而非基础框架。同时，SpringBoot使得程序员只需要继承一个SpringBoot parent工程就可以集成大量的框架并且避免依赖包的版本冲突，以及解决了引用的不稳定性等问题。
Spring Boot所具备的特征有：
（1）可以创建独立的Spring应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs；
（2）内嵌Tomcat或Jetty等Servlet容器；
（3）提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置；
（4）尽可能自动配置Spring容器；
（5）提供准备好的特性，如指标、健康检查和外部化配置；
（6）绝对没有代码生成，不需要XML配置。 [1]  [2]
SpringBoot框架中还有两个非常重要的策略：开箱即用和约定优于配置。开箱即用，
Outofbox，是指在开发过程中，通过在MAVEN项目的pom文件中添加相关依赖包，然后使用对应注解来代替繁琐的XML配置文件以管理对象的生命周期。这个特点使得开发人员摆脱了复杂的配置工作以及依赖的管理工作，更加专注于业务逻辑。约定优于配置，Convention over configuration，是一种由SpringBoot本身来配置目标结构，由开发者在结构中添加信息的软件设计范式。这一特点虽降低了部分灵活性，增加了BUG定位的复杂性，但减少了开发人员需要做出决定的数量，同时减少了大量的XML配置，并且可以将代码编译、测试和打包等工作自动化。
SpringBoot应用系统开发模板的基本架构设计从前端到后台进行说明：前端常使用模板引擎，主要有FreeMarker和Thymeleaf，它们都是用Java语言编写的，渲染模板并输出相应文本，使得界面的设计与应用的逻辑分离，同时前端开发还会使用到Bootstrap、AngularJS、JQuery等；在浏览器的数据传输格式上采用Json，非xml，同时提供RESTfulAPI；SpringMVC框架用于数据到达服务器后处理请求

虽然SpringBoot的使用非常简单，但是我们在开始项目前需要对其源代码有更加详细的了解，这样才能在应用中更加灵活自如。而SpringBoot中最让人困惑的可能就是自动配置了。我们从SpringBoot的入口类开始一步一步详细解释为什么SpringBoot可以实现自动配置。

@SpringBootApplication
public class SpringApplicationExample{
    public static void main(String[] args) {
        SpringApplication.run(SpringApplicationExample.class);
    }
}
通过Debug可以知道SpringBoot项目的自动配置入口文件是@EnableAutoConfiguration中的AutoConfigurationImportSelector.class

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class<?>[] exclude() default {};

    String[] excludeName() default {};
}
继续分析AutoConfigurationImportSelector源码中selectImports方法可以得知：
public String[] selectImports(AnnotationMetadata annotationMetadata) {
    if (!this.isEnabled(annotationMetadata)) {
        return NO_IMPORTS;
    } else {
        try {
            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);

            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);

            List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
            configurations = this.removeDuplicates(configurations);
            configurations = this.sort(configurations, autoConfigurationMetadata);
            Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
            this.checkExcludedClasses(configurations, exclusions);
            configurations.removeAll(exclusions);
            configurations = this.filter(configurations, autoConfigurationMetadata);
            this.fireAutoConfigurationImportEvents(configurations, exclusions);
            return (String[])configurations.toArray(new String[configurations.size()]);
        } catch (IOException var6) {
            throw new IllegalStateException(var6);
        }
    }
}

1.this.isEnabled(annotationMetaData)就是检查是否在yaml中配置了自动配置为false，如果用户自行配置了false，那么springboot将不会进行自动配置，则用户需要自行手动配置所有的插件

2.其中的静态方法AutoConfigurationMetadataLoader.loadMetadata会加载META-INF/spring-autoconfigure-metadata.properties的文件，而这个文件对后面SpringBoot过滤某些不需要的bean的配置有重要作用

截取里面一部分的内容进行解释：
org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration.ConditionalOnClass=com.mongodb.MongoClient
当springboot加载MongoAutoConfiguration自动配置类时会先自行检查是否已经存在MongoClient，如果没有存在，则自动配置就不会配置当前类，自动过滤掉，关于SpringBoot是如何实现这一个特性的我们在下文进行分析

3.接下来就是对自动配置类的过滤和筛选了，我们先对实例annotationMetaData进行仔细剖析：
public class StandardAnnotationMetadata extends StandardClassMetadata implements AnnotationMetadata {
   private final Annotation[] annotations;
   private final boolean nestedAnnotationsAsMap;

public StandardAnnotationMetadata(Class<?> introspectedClass) {
    this(introspectedClass, false);
}

在SpringBoot中这里的运行实例是StandardAnonotationMetaData类型，这个类型存储了我们入口类的字节码文件(即上面的introspectedClass)，在这里存储的就是SpringApplicationExample.class, 方便在进行自动配置时读取入口类的注解上的配置属性，可以告诉SpringBoot我们哪些Bean需要手动配置，哪些需要自动配置，让我们的开发更加得心应手

4.然后SpringBoot就会获取@SpringBootApplication复合注解中的@EnableAutonConfiguration的所有参数信息装入AnnotationAttributes实例中去，通过debug可以看到这里面有两个属性exclude和excludeName也证实了它的作用

    5.然后SpringBoot通过getCandidateConfigurations从路径META-INF/spring.factories文件中获得等待配置的候选自动配置类
protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
    Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");
    return configurations;
}

在这一步中的removeDuplicates(configurations)值得注意
configurations = this.removeDuplicates(configurations);
这里实现配置的去重是通过将一个list实例传入linkedHashSet中构造一个linkedhashset，而hashset只存储不同的string值，最后再构造一个arraylist实例就成功实现去重了
protected final <T> List<T> removeDuplicates(List<T> list) {
    return new ArrayList(new LinkedHashSet(list));
}
接下来通过这两行代码
Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
this.checkExcludedClasses(configurations, exclusions);
configurations.removeAll(exclusions);
Springboot将会从候选bean类中去除用户在@EnableAutoConfiguration中指定的取消自动配置的bean

用于SpringBoot自动配置，很多class的配置需要依赖另外class的存在，而filter这个方法的最主要的作用就是进一步筛选没有前置class的那些class从自动配置class的List中删除掉
private List<String> filter(List<String> configurations, AutoConfigurationMetadata autoConfigurationMetadata) {
    long startTime = System.nanoTime();
    String[] candidates = (String[])configurations.toArray(new String[configurations.size()]);
    boolean[] skip = new boolean[candidates.length];
    boolean skipped = false;
    Iterator var8 = this.getAutoConfigurationImportFilters().iterator();

    while(var8.hasNext()) {
        AutoConfigurationImportFilter filter = (AutoConfigurationImportFilter)var8.next();
        this.invokeAwareMethods(filter);
        boolean[] match = filter.match(candidates, autoConfigurationMetadata);

        for(int i = 0; i < match.length; ++i) {
            if (!match[i]) {
                skip[i] = true;
                skipped = true;
            }
        }
    }

    if (!skipped) {
        return configurations;
    } else {
        List<String> result = new ArrayList(candidates.length);

        int numberFiltered;
        for(numberFiltered = 0; numberFiltered < candidates.length; ++numberFiltered) {
            if (!skip[numberFiltered]) {
                result.add(candidates[numberFiltered]);
            }
        }

        if (logger.isTraceEnabled()) {
            numberFiltered = configurations.size() - result.size();
            logger.trace("Filtered " + numberFiltered + " auto configuration class in " + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime) + " ms");
        }

        return new ArrayList(result);
    }
}
















